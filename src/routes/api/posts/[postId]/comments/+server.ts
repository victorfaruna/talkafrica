import { json } from '@sveltejs/kit';
import { db } from '$lib/server/db';
import { commentsTable, usersTable } from '$lib/server/schema';
import { eq } from 'drizzle-orm';


export async function POST({ params, request }) {
    try {
        const { postId } = params;
        const { content, name, email } = await request.json();

        // Validation
        if (!content || !name || !email) {
            return json({ success: false, message: 'Missing required fields' }, { status: 400 });
        }

        if (!postId) {
            return json({ success: false, message: 'Post ID is required' }, { status: 400 });
        }

        // 1. Find or Create User
        // Check if user exists by email
        const existingUsers = await db.select().from(usersTable).where(eq(usersTable.email, email)).limit(1);

        let userId;
        let userName;

        if (existingUsers.length > 0) {
            // User exists, use their ID
            userId = existingUsers[0].user_id;
            userName = existingUsers[0].name; // Use stored name or the one provided? Stored seems safer for consistency, but maybe update? Let's use ID.
        } else {
            // User does not exist, create a guest user
            // Generate a unique username based on name or random
            const cleanName = name.replace(/[^a-zA-Z0-9]/g, '').toLowerCase().substring(0, 10);
            const randomSuffix = Math.floor(Math.random() * 10000);
            const username = `guest_${cleanName}_${randomSuffix}`;

            // Generate a new UUID for the user
            // Note: usersTable has user_id default, but we can also rely on returning it if we used .returning()
            // However, with drizzle-orm/postgres-js, let's insert and rely on default if possible, but for UUID consistency let's specific if we can, 
            // OR simpler: insert and assume success, but we need the ID.
            // Best pattern with Drizzle:

            const newUser = await db.insert(usersTable).values({
                name,
                email,
                username,
                role: 'user',
                status: 'active'
                // user_id will be auto-generated by default(sql`gen_random_uuid()`)
            }).returning({ user_id: usersTable.user_id });

            if (newUser && newUser.length > 0) {
                userId = newUser[0].user_id;
            } else {
                throw new Error('Failed to create guest user');
            }
        }

        // 2. Insert Comment
        const newComment = await db.insert(commentsTable).values({
            post_id: postId, // Assuming postId from param is already a UUID string or compatible
            user_id: userId,
            content,
            status: 'approved' // Auto-approve for now, or 'pending' if moderation is desired. Code said "It will appear after moderation" but list shows valid comments. Let's use 'approved' to see it immediately for "fix" verification, unless schema default is 'pending'. Schema default is 'approved'.
        }).returning();

        return json({ success: true, comment: newComment[0] });

    } catch (error) {
        console.error('Error submitting comment:', error);
        return json({ success: false, message: 'Internal server error' }, { status: 500 });
    }
}

export async function GET({ params }) {
    try {
        const { postId } = params;

        // Fetch comments for the post, ordered by date desc
        // We need to join with users to get author info

        // Drizzle specific join syntax or just manual for now if relations aren't set up
        // Simple select from comments where post_id = postId

        const comments = await db.select({
            comment_id: commentsTable.comment_id,
            user_id: commentsTable.user_id,
            content: commentsTable.content,
            status: commentsTable.status,
            created_at: commentsTable.created_at,
            user: {
                name: usersTable.name,
                email: usersTable.email
            }
        })
            .from(commentsTable)
            .leftJoin(usersTable, eq(commentsTable.user_id, usersTable.user_id))
            .where(eq(commentsTable.post_id, postId));

        // Sort in code or SQL. orderBy(desc(commentsTable.created_at))
        // Let's add sort.
        comments.sort((a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime());

        return json({ success: true, comments });

    } catch (error) {
        console.error('Error loading comments:', error);
        return json({ success: false, message: 'Internal server error' }, { status: 500 });
    }
}
